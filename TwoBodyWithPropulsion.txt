import numpy as np
from scipy.integrate import solve_ivp
import matplotlib.pyplot as plt
from utils.GetClassicOrbitalElements import *
from utils.visualization import plot_classic_orbital_elements

r0 = np.array([10016.34, -17012.52, 7899.28])
v0 = np.array([2.5, -1.05, 3.88])
t = np.linspace(0, 60000, 100000)
earth_radius = 6378.0  # km
mu = 3.986e5  # km³/s²

# Acelerações nas direções V (tangencial) e H (cross-track)
aV = 0.0001  # km/s² (exemplo)
aH = 0.00005 # km/s² (exemplo)

def x_dot(t, x):
    r_vec = x[0:3]
    v_vec = x[3:6]
    
    r_norm = np.linalg.norm(r_vec)
    
    # Gravidade (problema de dois corpos)
    a_grav = -(mu / r_norm**3) * r_vec
    
    # Vetores unitários do sistema RSW
    eR = r_vec / r_norm
    h_vec = np.cross(r_vec, v_vec)
    eW = h_vec / np.linalg.norm(h_vec)
    eS = np.cross(eW, eR)
    
    # Aceleração de propulsão nas direções V (along-track) e H (cross-track)
    a_thrust = aV * eS + aH * eW
    
    # Derivadas
    xdot = np.zeros_like(x)
    xdot[0:3] = v_vec
    xdot[3:6] = a_grav + a_thrust
    
    return xdot

x0 = np.concatenate((r0, v0)) 
sol = solve_ivp(x_dot, (t[0], t[-1]), x0, t_eval=t, method='RK45')

X = sol.y

orbital_elementss = []
for i in range(X.shape[1]):
    x_state = X[:, i]
    orbital_elementss.append(get_orbital_elements(x_state[0:3], x_state[3:6], mu))

# Plot 3D
plt.figure()
ax = plt.axes(projection='3d')
u, v = np.mgrid[0:2*np.pi:20j, 0:np.pi:10j]
x_sphere = earth_radius * np.cos(u)*np.sin(v)
y_sphere = earth_radius * np.sin(u)*np.sin(v)
z_sphere = earth_radius * np.cos(v)
ax.plot_wireframe(x_sphere, y_sphere, z_sphere, color="r")
ax.plot3D(X[0, :], X[1, :], X[2, :], 'b-')
ax.set_title('Orbit Propagation with Thrust in V and H')
ax.set_box_aspect([1,1,1])
plt.show()

plot_classic_orbital_elements(t, orbital_elementss)



